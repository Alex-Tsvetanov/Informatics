(I7
I238
I21
(dp0
Vproject.%l
p1
(Vproject.cpp
p2
S'#include <bits/stdc++.h>\n#define endl \'\\n\'\nusing namespace std;\n\nconst long long maxN = 1e5 + 5, maxM = 2e5 + 5;\n\nstruct edge\n{\n\tlong long node_to, weight;\n\t\n\tedge(){}\n\tedge(long long node_to, long long weight)\n\t{\n\t\tthis->node_to = node_to;\n\t\tthis->weight = weight;\n\t}\n};\n\nlong long n, m, a[maxM], b[maxM], c[maxM], cnt_in[maxN], cnt_out[maxN], dist_max[maxN], max_time, dist_min[maxN], dist_reversed[maxN];\nvector<edge> graph[maxN], reversed_graph[maxN];\npriority_queue<edge> pq;\n\nbool operator< (edge x, edge y)\n{\n\treturn x.weight > y.weight;\n}\nvoid dijkstra_max(long long start_node)\n{\n\tdist_max[start_node] = 0;\n\tpq.push(edge(start_node, 0));\n\t\n\tlong long current_node, current_weight, new_node_to, new_weight;\n\twhile(!pq.empty())\n\t{\n\t\tcurrent_node = pq.top().node_to;\n\t\tcurrent_weight = pq.top().weight;\n\t\tpq.pop();\n\t\t\n\t\tfor(long long i = 0; i < graph[current_node].size(); i++)\n\t\t{\n\t\t\tnew_node_to = graph[current_node][i].node_to;\n\t\t\tnew_weight = graph[current_node][i].weight;\n\t\t\tif((dist_max[new_node_to] == -1 || dist_max[new_node_to] < current_weight + new_weight))\n\t\t\t{\n\t\t\t\tdist_max[new_node_to] = current_weight + new_weight;\n\t\t\t\tpq.push(edge(new_node_to, dist_max[new_node_to]));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dijkstra_min(long long start_node)\n{\n\tdist_min[start_node] = 0;\n\tpq.push(edge(start_node, 0));\n\t\n\tlong long current_node, current_weight, new_node_to, new_weight;\n\twhile(!pq.empty())\n\t{\n\t\tcurrent_node = pq.top().node_to;\n\t\tcurrent_weight = pq.top().weight;\n\t\tpq.pop();\n\t\t\n\t\tfor(long long i = 0; i < graph[current_node].size(); i++)\n\t\t{\n\t\t\tnew_node_to = graph[current_node][i].node_to;\n\t\t\tnew_weight = graph[current_node][i].weight;\n\t\t\tif((dist_min[new_node_to] == -1 || dist_min[new_node_to] > current_weight + new_weight))\n\t\t\t{\n\t\t\t\tdist_min[new_node_to] = current_weight + new_weight;\n\t\t\t\tpq.push(edge(new_node_to, dist_min[new_node_to]));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dijkstra_reversed(long long start_node)\n{\n\tdist_reversed[start_node] = 0;\n\tpq.push(edge(start_node, 0));\n\t\n\tlong long current_node, current_weight, new_node_to, new_weight;\n\twhile(!pq.empty())\n\t{\n\t\tcurrent_node = pq.top().node_to;\n\t\tcurrent_weight = pq.top().weight;\n\t\tpq.pop();\n\t\t\n\t\tfor(long long i = 0; i < reversed_graph[current_node].size(); i++)\n\t\t{\n\t\t\tnew_node_to = reversed_graph[current_node][i].node_to;\n\t\t\tnew_weight = reversed_graph[current_node][i].weight;\n\t\t\tif((dist_reversed[new_node_to] == -1 || dist_reversed[new_node_to] < current_weight + new_weight))\n\t\t\t{\n\t\t\t\tdist_reversed[new_node_to] = current_weight + new_weight;\n\t\t\t\tpq.push(edge(new_node_to, dist_reversed[new_node_to]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tcin>>m>>n;\n\tfor(long long i = 0; i < m; i++)\n\t{\n\t\tcin>>a[i]>>b[i]>>c[i];\n\t\t\n\t\tgraph[a[i]].push_back(edge(b[i], c[i]));\n\t\treversed_graph[b[i]].push_back(edge(a[i], c[i]));\n\t\tcnt_in[b[i]]++;\n\t\tcnt_out[a[i]]++;\n\t}\n\t\n\tmemset(dist_max, -1, sizeof(dist_max));\n\tmemset(dist_min, -1, sizeof(dist_min));\n\tmemset(dist_reversed, -1, sizeof(dist_reversed));\n\tfor(long long i = 0; i < n; i++)\n\t{\n\t\tif(cnt_in[i] == 0) \n\t\t{\n\t\t\tdijkstra_max(i);\n\t\t\tdijkstra_min(i);\n\t\t}\n\t\tif(cnt_out[i] == 0) dijkstra_reversed(i);\n\t}\n\t\n\t/*cout<<"control print"<<endl;\n\tfor(long long i = 0; i < n; i++)\n\t{\n\t\tcout<<i<<" "<<dist_min[i]<<" "<<dist_max[i]<<" "<<dist_reversed[i]<<endl;\n\t}*/ \n\t\n\tfor(long long i = 0; i < n; i++)\n\t{\n\t\tif(dist_max[i] > max_time) max_time = dist_max[i];\n\t\t//cout<<dist_reversed[i]<<endl;\n\t}\n\t\n\tcout<<max_time<<endl;\n\tfor(long long i = 0; i < m; i++)\n\t{\n\t\tcout<<dist_min[a[i]]<<" "<<max_time - dist_reversed[b[i]] - c[i]<<endl;\n\t}\n\treturn 0;\n}\n'
p3
tp4
stp5
.